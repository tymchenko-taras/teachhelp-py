from django.shortcuts import render, get_object_or_404, redirect
from django.utils import timezone
from django.http import HttpResponse
from .models import Sentence
from django.core.paginator import Paginator
from django.views.generic import ListView
from django.db import connection
from lxml import etree
import csv
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
import datetime
from django.http import StreamingHttpResponse
import time
import re
from django.utils.html import escape
from django.db import connections



class SentenceView(ListView):
    model = Sentence
    template_name = 'api/sentence_list.html'  # Default: <app_label>/<model_name>_list.html
    context_object_name = 'sentences'  # Default: object_list
    paginate_by = 100
    queryset = Sentence.objects.all()  # Default: Model.objects.all()

class Echo(object):
    """An object that implements just the write method of the file-like
    interface.
    """
    def write(self, value):
        """Write the value by returning it, instead of storing in a buffer."""
        time.sleep(1)
        return value


def get_xml(sentences):
    yield '''<?xml version="1.0" encoding="UTF-8"?>
 <sphinx:docset>
  <sphinx:schema>
   <sphinx:field name="content"/>
   <sphinx:attr name='itemId' type='int' bits='16'/>
   <sphinx:attr name='flags' type='multi'/>
   <sphinx:attr name='content' type='string'/>
  </sphinx:schema>'''
    i = 0
    for sentence in sentences:
        # flags = '';
        # result = Sentence().process_sentence_by_expressions(sentence.content)
        # if 1 in result and 2 in result and 3 in result and result[1] and result[2] and not result[3]:
        #     flags = '<items id="0">1</items>';
        #yield '<sphinx:document id="' + str(sentence.id) + '"><content>' + escape(sentence.content) + '</content><itemId>' + str(sentence.id)    + '</itemId><flags>'+flags+'</flags></sphinx:document>'
        i = i + 1
        yield '<sphinx:document id="'+ str(i) +'"><content>lalala</content><itemId>1</itemId><flags></flags></sphinx:document>'
    yield '</sphinx:docset>'


def sentences_xml(request):
    # result = Sentence().get_approximate_flags('going to school is')
    #
    return HttpResponse({'2'})


    connection = connections['sphinx']
    start_time = time.time()
    offset = 0
    limit = 50000
    while True:
        sentences = Sentence.objects.all()[offset:limit+offset]
        # sentences = Sentence.objects.all()[:limit]
        offset = offset + limit
        if not sentences.exists():
            break

        values = []
        params = []
        for sentence in sentences:
            flags = Sentence().get_approximate_flags(sentence.content)

            values.append('('+ str(sentence.id) +', %s, ('+ ','.join({str(flag) for flag in flags}) +'))')
            params.extend([sentence.content])

        with connection.cursor() as cursor:
            sql = 'REPLACE INTO  paragraph_rt (id, content, flags_t) VALUES ' + (', '.join(values))
            cursor.execute(sql, params)

        # with open('test.txt', 'w') as f:
        #     f.write(str(limit) + '\n')
        # break
    return HttpResponse({"--- %s seconds ---" % (time.time() - start_time)})


def sentences_xml2(request):
    """A view that streams a large CSV file."""
    # Generate a sequence of rows. The range is based on the maximum number of
    # rows that can be handled by a single sheet in most spreadsheet
    # applications.
    #sentences = Sentence.objects.all()[:1000]
    sentences = [{'id':1, 'content':''}]*100000

    response = HttpResponse((x for x in range(100000)))
    # response = StreamingHttpResponse((x for x in range(100000)))
    # response = StreamingHttpResponse(get_xml(sentences))
    # response = HttpResponse(get_xml(sentences), content_type="text/xml")
    return response

def sentences_xml1(request):

    generated_on = str(datetime.datetime.now())

    # Configure one attribute with set()
    root = Element('opml')
    root.set('version', '1.0')

    root.append(Comment('Generated by ElementTree_csv_to_xml.py for PyMOTW'))

    head = SubElement(root, 'head')
    title = SubElement(head, 'title')
    title.text = 'My Podcasts'
    dc = SubElement(head, 'dateCreated')
    dc.text = generated_on
    dm = SubElement(head, 'dateModified')
    dm.text = generated_on

    body = SubElement(root, 'body')


    current_group = None


    group_name = 'g1'
    podcast_name = 'p1'
    xml_url = 'u1'
    html_url = 'h1'
    if current_group is None or group_name != current_group.text:
        # Start a new group
        current_group = SubElement(body, 'outline', {'text': group_name})
    # Add this podcast to the group,
    # setting all of its attributes at
    # once.
    podcast = SubElement(current_group, 'outline',
                         {'text': podcast_name,
                          'xmlUrl': xml_url,
                          'htmlUrl': html_url,
                          })

    # print(root)
    return HttpResponse(root)





    # r = Sentence().process_sentence_by_expressions(text='tommy`s working is good')
    # post = get_object_or_404(Sentence, pk=1)
    # sentences = Sentence.objects.all()[:1000]
    # for sentence in sentences:
    #     flags = sentence.get_expressions_result()
    # return HttpResponse({})
    #
    # count = Sentence.objects.count();
    # all = Sentence.objects.all();
    # for post in all:
    #     return HttpResponse(post.content, content_type='application/json')
    # import nltk
    # posts = Post.objects.filter(created_date__lte=timezone.now()).order_by('published_date')
    # return render(request, 'blog/post_list.html', {'posts': posts})
